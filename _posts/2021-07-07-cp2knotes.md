---
layout: post
title: CP2K calculation on the run
published: true
tags: AIMD CP2K packages
---

## CP2K calculation basics

### basic knowledge

First, this is a cool CP2K ASCII art generated in the output file.

```shell
 **** **** ******  **
***** ** ***  *** ** 
**    ****   ******  
***** **    ** ** ** 
 **** **  *******  **
```

These are the basic command line options of cp2k, you basically load the module and write the following code in terminal:

```shell
# PC
cp2k.sopt -i input_file -o output_file &
# or HPC
mpirun -n 32 cp2k.popt input_file -o output_file &
# by defalut, if there is no output assinged, output goes to stdout.
```
However, this is not how we run jobs in HPC. We should use `lsf` script in 191 node.

```shell
# the *.lsf file
[rhbi@mgt02 00.calculate_energy_and_force]$ cat cp2k.lsf 
#!/bin/bash
#
#BSUB -q 52-medium					## lsf queue-name (small, medium, 														   large)
#BSUB -W 12:00							## wall time, terminite this job 																 after 12:00 hours
#BSUB -J rutile-e-f					## The job name
#BSUB -o cp2k.%J.stdout			## standard output file
#BSUB -e cp2k.%J.stderr			## standard error file
#BSUB -n 28									## use 28 cores (CPU)
#BSUB -R "span[ptile=28]"		## using 28 nodes per core

# add modulefiles
module load intel/17.5.239 mpi/intel/2017.5.239
module load gcc/5.5.0
module load cp2k/7.1

mpiexec.hydra cp2k.popt input.inp >& output_$LSB_JOBID

# actually submit using lsf system
busb < cp2k.lsf
```

In the `*.lsf` file, there are three parts. The first part starts with `#BSUB` determines the properties of a job (see the description in the above code block). The second part loads the required module used in this particular job. The final part is actually the true command to execute cp2k calculation.

> There are unkown terms, study on them
> - what is mpi? `mpiexec.hydra`?  `mpirun`
> - what is CPU **core**? what is **node**?

It's easy to check version or get help:
```shell
cp2k.popt -version
cp2k.popt -check input_file			# what does this do actually?
cp2k.popt -html-manual
cp2k.popt -help
```
> What does `cp2k.popt -check <input>.inp` do?

### Basic interaction 

The directory of your job looks like:

```shell
[rhbi@mgt02 cp2k_tutorial]$ tree
.
├── 00.calculate_energy_and_force
│   ├── cp2k.178395.stderr
│   ├── cp2k.178395.stdout
│   ├── cp2k.lsf
│   ├── input.inp
│   ├── output_178395
│   ├── rutile.xyz
│   ├── Universality-RESTART.wfn
│   ├── Universality-RESTART.wfn.bak-1
│   ├── Universality-RESTART.wfn.bak-2
│   └── Universality-RESTART.wfn.bak-3
└── README.md

1 directory, 11 files
```

The basic interaction with `cp2k` is:

1. feed `cp2k` the inputs
	- `input.inp`
	- `<structure>.xyz`
2. `lsf` script creates job, `cp2k` starts to work, generating files
3. `cp2k` outputs the following files
	- `*.restart` (input file to restart calculation)
	- `*.xyz` (trajectory for MD)
	- `*.ener` (MD energies, temperatures)
	- `*.cell` (cell parameters)
	- `*-RESTEART.wfn` (orbitals for restart)

### The structure of the input file

The information in the input file are preseted is different **sections**, which are marked in uppercase keywords like `GLOBAL`, `FORCE_EVAL`, ..., etc. The basic syntax of a `KEYWORD` section is 

```
&KEYWORD
	PROPERTY1 <PROPERTY1 value>
	PROPERTY2 <PROPERTY2 value>
	...
&END KEYWORD
```
The input file consists of many sections , and we tell what kind of calculation of we want to run by writting details in each section. The following code block contains the tutorial `cp2k` run of rutile energy-force calculatin.

```
# input.inp

&FORCE_EVAL
  METHOD QS
  &PRINT
    &FORCES ON
    &END FORCES
  &END PRINT
  &DFT
    BASIS_SET_FILE_NAME BASIS_MOLOPT
    POTENTIAL_FILE_NAME GTH_POTENTIALS
    &MGRID
      CUTOFF 400
      REL_CUTOFF 60
    &END MGRID
    &QS
      EPS_DEFAULT 1.0E-13
    &END QS
    &SCF
      SCF_GUESS RESTART
      EPS_SCF 3.0E-7
      MAX_SCF 50
      &OUTER_SCF
        EPS_SCF 3.0E-7
        MAX_SCF 10
      &END OUTER_SCF
      &OT
        MINIMIZER DIIS
        PRECONDITIONER FULL_SINGLE_INVERSE
      &END OT
    &END SCF
    &XC
      ########## This part is PBE ##########
      &XC_FUNCTIONAL PBE
      &END XC_FUNCTIONAL
      ########## This part is PBE ##########
    &END XC
  &END DFT
  &SUBSYS
    &CELL 
      ABC [angstrom]    4.593 4.593 2.959
    &END CELL
    &COORD
@include rutile.xyz
    &END COORD
    &KIND O
      BASIS_SET DZVP-MOLOPT-SR-GTH 
      POTENTIAL GTH-PBE-q6
    &END KIND
    &KIND Ti  
      BASIS_SET DZVP-MOLOPT-SR-GTH
      POTENTIAL GTH-PBE-q12
    &END KIND
  &END SUBSYS
&END FORCE_EVAL

&GLOBAL
  PROJECT Universality 
  RUN_TYPE ENERGY_FORCE
  PRINT_LEVEL MEDIUM
&END GLOBAL
```

The most important sections are`GLOBAL` and `FORCE_EVAL`, which contain the general options (job name, type of job) and all parameters associated with the evaluation of force respectively. We can see the above file contains only this two sections.

Let's start to look in to the structure of this file form the `GLOBAL` section.

```
# The GLOBAL section

&GLOBAL
  PROJECT Universality	# dictate the name of  the .wfn file
  RUN_TYPE ENERGY_FORCE	# This is a energy-force calculation
  											# Alternatively, this can also be GEO_OPT
  PRINT_LEVEL MEDIUM		# dictats the verbosity
&END GLOBAL
```

The global sectio contains the following info:

- name of the project
- how many is printed out
- what calculation job?

More interestingly, the `FORCE_EVAL` part in more complex.

```
# The overall structure overview of FORCE_EVAL

&FORCE_EVAL
  METHOD QS
  &PRINT
	...
  &END PRINT
  &DFT
  ...
  &END DFT
  &SUBSYS
  ...
  &END SUBSYS
&END FORCE_EVAL
```
On the top of `FORCE_EVAL` part, the method of calculation is selected using KEYWORD `METHOD`, our system uses `QS`, which is the acronym of `Quickstep`. This will guarantee we are using **GPW method in Density Functional Theory** to calculate energy and force. Following are the subsections in `FORCE_EVAL`:

- `PRINT`: How much information you want to get
- `DFT`: Basis to use, the cutoff energy to select PW basis set, `EPS` tolerence, self consistance field setup, exchange-correlation (XC) setup,...,etc.
- `SUBSYS`: the cell parameters, atom coordinates (input via `*.xyz`), assign basis set and pseudopotential to each kind of atom, ..., etc.